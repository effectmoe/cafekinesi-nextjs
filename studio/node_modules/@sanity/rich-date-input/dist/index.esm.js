import { unset, set, DateTimeInput, ObjectInputMember, defineType, defineField, definePlugin } from 'sanity';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { Button, Box, Autocomplete, Card, Text, Flex, Dialog } from '@sanity/ui';
import { useCallback, useState } from 'react';
import { formatInTimeZone, zonedTimeToUtc, getTimezoneOffset } from 'date-fns-tz';
import { getTimeZones } from '@vvo/tzdb';
import { EarthAmericasIcon, SearchIcon } from '@sanity/icons';
const unlocalizeDateTime = (datetime, timezone) => {
  return formatInTimeZone(datetime, timezone, "yyyy-MM-dd HH:mm:ss");
};
const getConstructedUTCDate = (utc, offset) => {
  const date = new Date(utc);
  const currentOffset = date.getTimezoneOffset() * -1;
  const diff = currentOffset - offset;
  const fakeUTCDate = new Date(date.getTime() - diff * 60 * 1e3);
  return fakeUTCDate.toISOString();
};
const allTimezones = getTimeZones().map(tz => {
  return {
    abbreviation: tz.abbreviation,
    alternativeName: tz.alternativeName,
    mainCities: tz.mainCities.join(", "),
    // Main time zone name 'Africa/Dar_es_Salaam'
    name: tz.name,
    // Time zone name with underscores removed
    namePretty: tz.name.replaceAll("_", " "),
    offset: tz.currentTimeFormat.split(" ")[0],
    // all searchable text - this is transformed before being rendered in `<AutoComplete>`
    value: "".concat(tz.currentTimeFormat, " ").concat(tz.abbreviation, " ").concat(tz.name),
    currentTimeOffsetInMinutes: tz.currentTimeOffsetInMinutes,
    group: tz.group
  };
});
const RelativeDateTimePicker = props => {
  const {
    dateValue: value,
    onChange
  } = props;
  const handleDateChange = useCallback(patch => {
    var _a;
    const timezone = (_a = value == null ? void 0 : value.timezone) != null ? _a : Intl.DateTimeFormat().resolvedOptions().timeZone;
    const newDatetime = patch == null ? void 0 : patch.value;
    if (!newDatetime || !("type" in patch) || patch.type !== "set") {
      onChange(unset());
      return;
    }
    const desiredDateTime = unlocalizeDateTime(newDatetime, Intl.DateTimeFormat().resolvedOptions().timeZone);
    const newUtcDateObject = zonedTimeToUtc(desiredDateTime, timezone);
    const newOffset = getTimezoneOffset(timezone, newUtcDateObject) / 60 / 1e3;
    const localDate = formatInTimeZone(newUtcDateObject, timezone, "yyyy-MM-dd'T'HH:mm:ssXXX");
    const patches = [];
    patches.push(set(newUtcDateObject.toISOString(), ["utc"]));
    patches.push(set(localDate, ["local"]));
    if (!(value == null ? void 0 : value.timezone)) {
      patches.push(set(timezone, ["timezone"]));
    }
    if ((value == null ? void 0 : value.offset) !== newOffset) {
      patches.push(set(newOffset, ["offset"]));
    }
    onChange(patches);
  }, [onChange, value]);
  const dateToDisplay = (value == null ? void 0 : value.utc) ? getConstructedUTCDate(value.utc, value.offset) : "";
  return /* @__PURE__ */jsx(DateTimeInput, {
    ...props,
    onChange: handleDateChange,
    value: dateToDisplay
  });
};
const TimezoneButton = props => {
  var _a, _b, _c, _d, _e;
  const {
    onClick,
    timezone
  } = props;
  const currentTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const label = (_e = (_c = (_a = allTimezones.find(tz => tz.name === timezone)) == null ? void 0 : _a.abbreviation) != null ? _c : (_b = allTimezones.find(tz => tz.name === currentTimezone)) == null ? void 0 : _b.abbreviation) != null ? _e : (_d = allTimezones.find(tz => tz.group.includes(currentTimezone))) == null ? void 0 : _d.abbreviation;
  return /* @__PURE__ */jsx(Button, {
    fontSize: 1,
    style: {
      width: "100%"
    },
    justify: "flex-start",
    icon: EarthAmericasIcon,
    mode: "ghost",
    onClick,
    text: "".concat(label),
    "aria-label": "Select a timezone"
  });
};
const TimezoneSelector = props => {
  var _a, _b;
  const {
    onChange,
    value
  } = props;
  const currentTz = allTimezones.find(tz => tz.name === (value == null ? void 0 : value.timezone));
  const userTzName = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const userTz = (_a = allTimezones.find(tz => tz.name === userTzName)) != null ? _a : allTimezones.find(tz => tz.group.includes(userTzName));
  const handleTimezoneChange = useCallback(selectedTz => {
    var _a2;
    const newTimezone = (_a2 = allTimezones.find(tz => tz.value === selectedTz)) != null ? _a2 : userTz;
    const timezonePatch = set(newTimezone.name, ["timezone"]);
    const patches = [timezonePatch];
    if (value == null ? void 0 : value.utc) {
      const desiredDateTime = unlocalizeDateTime(value.utc, value.timezone);
      const newUtcDateObject = zonedTimeToUtc(desiredDateTime, newTimezone.name);
      const newOffset = getTimezoneOffset(newTimezone.name, newUtcDateObject) / 60 / 1e3;
      const newLocalDate = formatInTimeZone(newUtcDateObject.toISOString(), newTimezone.name, "yyyy-MM-dd'T'HH:mm:ssXXX");
      patches.push(set(newUtcDateObject.toISOString(), ["utc"]));
      patches.push(set(newLocalDate, ["local"]));
      patches.push(set(newOffset, ["offset"]));
    }
    onChange(patches);
  }, [onChange, userTz, value]);
  return (
    // taken from Scheduled Publishing, again!
    // https://github.com/sanity-io/sanity-plugin-scheduled-publishing/blob/bb282e3df9a8a73df37fab8ee1fdd0e2430745be/src/components/dialogs/DialogTimeZone.tsx#L100
    /* @__PURE__ */
    jsx(Box, {
      padding: 4,
      children: /* @__PURE__ */jsx(Autocomplete, {
        fontSize: 2,
        icon: SearchIcon,
        id: "timezone",
        onChange: handleTimezoneChange,
        openButton: true,
        options: allTimezones,
        padding: 4,
        placeholder: "Search for a city or time zone",
        popover: {
          boundaryElement: document.querySelector("body"),
          constrainSize: true,
          placement: "bottom-start"
        },
        renderOption: option => {
          return /* @__PURE__ */jsx(Card, {
            as: "button",
            padding: 3,
            children: /* @__PURE__ */jsxs(Text, {
              size: 1,
              textOverflow: "ellipsis",
              children: [/* @__PURE__ */jsxs("span", {
                children: ["GMT", option.offset]
              }), /* @__PURE__ */jsx("span", {
                style: {
                  fontWeight: 500,
                  marginLeft: "1em"
                },
                children: option.alternativeName
              }), /* @__PURE__ */jsx("span", {
                style: {
                  marginLeft: "1em"
                },
                children: option.mainCities
              })]
            })
          });
        },
        renderValue: (_, option) => {
          if (!option) return "";
          return "".concat(option.alternativeName, " (").concat(option.namePretty, ")");
        },
        tabIndex: -1,
        value: (_b = currentTz == null ? void 0 : currentTz.value) != null ? _b : userTz.value
      })
    })
  );
};
const RichDateInput = props => {
  const {
    onChange,
    value,
    members,
    schemaType
  } = props;
  const {
    options
  } = schemaType;
  const localMember = members.find(member => member.kind === "field" && member.name === "local");
  const timezoneMember = members.find(member => member.kind === "field" && member.name === "timezone");
  const [timezoneSelectorOpen, setTimezoneSelectorOpen] = useState(false);
  const onClose = useCallback(() => setTimezoneSelectorOpen(false), []);
  const onOpen = useCallback(() => setTimezoneSelectorOpen(true), []);
  return /* @__PURE__ */jsxs(Fragment, {
    children: [/* @__PURE__ */jsxs(Flex, {
      children: [/* @__PURE__ */jsx(Box, {
        flex: [1, 2, 4],
        children: localMember && /* @__PURE__ */jsx(ObjectInputMember, {
          ...props,
          member: localMember,
          renderInput: renderInputProps => /* @__PURE__ */jsx(RelativeDateTimePicker, {
            ...renderInputProps,
            dateValue: value,
            schemaType: {
              ...renderInputProps.schemaType,
              options
            },
            onChange
          })
        })
      }), /* @__PURE__ */jsx(Box, {
        flex: [1],
        marginLeft: [2, 2, 3, 4],
        children: timezoneMember && /* @__PURE__ */jsx(ObjectInputMember, {
          ...props,
          member: timezoneMember,
          renderInput: () => {
            var _a;
            return /* @__PURE__ */jsx(TimezoneButton, {
              onClick: onOpen,
              timezone: (_a = value == null ? void 0 : value.timezone) != null ? _a : ""
            });
          }
        })
      })]
    }), timezoneSelectorOpen && /* @__PURE__ */jsx(Dialog, {
      onClose,
      header: "Select a timezone",
      id: "timezone-select",
      width: 1,
      children: /* @__PURE__ */jsx(TimezoneSelector, {
        onChange,
        value
      })
    })]
  });
};
const richDateTypeName = "richDate";
const richDateSchema = defineType({
  name: richDateTypeName,
  title: "Rich Date",
  type: "object",
  fields: [defineField({
    name: "local",
    title: "Local",
    type: "string"
  }), defineField({
    name: "utc",
    title: "UTC",
    type: "string"
  }), defineField({
    name: "timezone",
    title: "Timezone",
    type: "string"
  }), defineField({
    name: "offset",
    title: "Offset",
    type: "number"
  })],
  components: {
    input: RichDateInput
  }
});
const richDate = definePlugin({
  name: "v3-rich-date-input",
  schema: {
    types: [richDateSchema]
  }
});
export { richDate };
//# sourceMappingURL=index.esm.js.map
